{
  "version": 3,
  "sources": ["../../src/index.ts", "../../../node_modules/@tldraw/vec/src/index.ts", "../../src/spline.ts", "../../src/perfect-cursor.ts"],
  "sourcesContent": ["export * from './perfect-cursor'\n", "export class Vec {\n  /**\n   * Clamp a value into a range.\n   * @param n\n   * @param min\n   */\n  static clamp(n: number, min: number): number\n  static clamp(n: number, min: number, max: number): number\n  static clamp(n: number, min: number, max?: number): number {\n    return Math.max(min, typeof max !== 'undefined' ? Math.min(n, max) : n)\n  }\n\n  /**\n   * Clamp a value into a range.\n   * @param n\n   * @param min\n   */\n  static clampV(A: number[], min: number): number[]\n  static clampV(A: number[], min: number, max: number): number[]\n  static clampV(A: number[], min: number, max?: number): number[] {\n    return A.map((n) => (max ? Vec.clamp(n, min, max) : Vec.clamp(n, min)))\n  }\n\n  /**\n   * Negate a vector.\n   * @param A\n   */\n  static neg = (A: number[]): number[] => {\n    return [-A[0], -A[1]]\n  }\n\n  /**\n   * Add vectors.\n   * @param A\n   * @param B\n   */\n  static add = (A: number[], B: number[]): number[] => {\n    return [A[0] + B[0], A[1] + B[1]]\n  }\n\n  /**\n   * Add scalar to vector.\n   * @param A\n   * @param B\n   */\n  static addScalar = (A: number[], n: number): number[] => {\n    return [A[0] + n, A[1] + n]\n  }\n\n  /**\n   * Subtract vectors.\n   * @param A\n   * @param B\n   */\n  static sub = (A: number[], B: number[]): number[] => {\n    return [A[0] - B[0], A[1] - B[1]]\n  }\n\n  /**\n   * Subtract scalar from vector.\n   * @param A\n   * @param B\n   */\n  static subScalar = (A: number[], n: number): number[] => {\n    return [A[0] - n, A[1] - n]\n  }\n\n  /**\n   * Get the vector from vectors A to B.\n   * @param A\n   * @param B\n   */\n  static vec = (A: number[], B: number[]): number[] => {\n    // A, B as vectors get the vector from A to B\n    return [B[0] - A[0], B[1] - A[1]]\n  }\n\n  /**\n   * Vector multiplication by scalar\n   * @param A\n   * @param n\n   */\n  static mul = (A: number[], n: number): number[] => {\n    return [A[0] * n, A[1] * n]\n  }\n\n  /**\n   * Multiple two vectors.\n   * @param A\n   * @param B\n   */\n  static mulV = (A: number[], B: number[]): number[] => {\n    return [A[0] * B[0], A[1] * B[1]]\n  }\n\n  /**\n   * Vector division by scalar.\n   * @param A\n   * @param n\n   */\n  static div = (A: number[], n: number): number[] => {\n    return [A[0] / n, A[1] / n]\n  }\n\n  /**\n   * Vector division by vector.\n   * @param A\n   * @param n\n   */\n  static divV = (A: number[], B: number[]): number[] => {\n    return [A[0] / B[0], A[1] / B[1]]\n  }\n\n  /**\n   * Perpendicular rotation of a vector A\n   * @param A\n   */\n  static per = (A: number[]): number[] => {\n    return [A[1], -A[0]]\n  }\n\n  /**\n   * Dot product\n   * @param A\n   * @param B\n   */\n  static dpr = (A: number[], B: number[]): number => {\n    return A[0] * B[0] + A[1] * B[1]\n  }\n\n  /**\n   * Cross product (outer product) | A X B |\n   * @param A\n   * @param B\n   */\n  static cpr = (A: number[], B: number[]): number => {\n    return A[0] * B[1] - B[0] * A[1]\n  }\n\n  /**\n   * Cross (for point in polygon)\n   *\n   */\n  static cross(x: number[], y: number[], z: number[]): number {\n    return (y[0] - x[0]) * (z[1] - x[1]) - (z[0] - x[0]) * (y[1] - x[1])\n  }\n\n  /**\n   * Length of the vector squared\n   * @param A\n   */\n  static len2 = (A: number[]): number => {\n    return A[0] * A[0] + A[1] * A[1]\n  }\n\n  /**\n   * Length of the vector\n   * @param A\n   */\n  static len = (A: number[]): number => {\n    return Math.hypot(A[0], A[1])\n  }\n\n  /**\n   * Project A over B\n   * @param A\n   * @param B\n   */\n  static pry = (A: number[], B: number[]): number => {\n    return Vec.dpr(A, B) / Vec.len(B)\n  }\n\n  /**\n   * Get normalized / unit vector.\n   * @param A\n   */\n  static uni = (A: number[]): number[] => {\n    return Vec.div(A, Vec.len(A))\n  }\n\n  /**\n   * Get normalized / unit vector.\n   * @param A\n   */\n  static normalize = (A: number[]): number[] => {\n    return Vec.uni(A)\n  }\n\n  /**\n   * Get the tangent between two vectors.\n   * @param A\n   * @param B\n   * @returns\n   */\n  static tangent = (A: number[], B: number[]): number[] => {\n    return Vec.uni(Vec.sub(A, B))\n  }\n\n  /**\n   * Dist length from A to B squared.\n   * @param A\n   * @param B\n   */\n  static dist2 = (A: number[], B: number[]): number => {\n    return Vec.len2(Vec.sub(A, B))\n  }\n\n  /**\n   * Dist length from A to B\n   * @param A\n   * @param B\n   */\n  static dist = (A: number[], B: number[]): number => {\n    return Math.hypot(A[1] - B[1], A[0] - B[0])\n  }\n\n  /**\n   * A faster, though less accurate method for testing distances. Maybe faster?\n   * @param A\n   * @param B\n   * @returns\n   */\n  static fastDist = (A: number[], B: number[]): number[] => {\n    const V = [B[0] - A[0], B[1] - A[1]]\n    const aV = [Math.abs(V[0]), Math.abs(V[1])]\n    let r = 1 / Math.max(aV[0], aV[1])\n    r = r * (1.29289 - (aV[0] + aV[1]) * r * 0.29289)\n    return [V[0] * r, V[1] * r]\n  }\n\n  /**\n   * Angle between vector A and vector B in radians\n   * @param A\n   * @param B\n   */\n  static ang = (A: number[], B: number[]): number => {\n    return Math.atan2(Vec.cpr(A, B), Vec.dpr(A, B))\n  }\n\n  /**\n   * Angle between vector A and vector B in radians\n   * @param A\n   * @param B\n   */\n  static angle = (A: number[], B: number[]): number => {\n    return Math.atan2(B[1] - A[1], B[0] - A[0])\n  }\n\n  /**\n   * Mean between two vectors or mid vector between two vectors\n   * @param A\n   * @param B\n   */\n  static med = (A: number[], B: number[]): number[] => {\n    return Vec.mul(Vec.add(A, B), 0.5)\n  }\n\n  /**\n   * Vector rotation by r (radians)\n   * @param A\n   * @param r rotation in radians\n   */\n  static rot = (A: number[], r = 0): number[] => {\n    return [A[0] * Math.cos(r) - A[1] * Math.sin(r), A[0] * Math.sin(r) + A[1] * Math.cos(r)]\n  }\n\n  /**\n   * Rotate a vector around another vector by r (radians)\n   * @param A vector\n   * @param C center\n   * @param r rotation in radians\n   */\n  static rotWith = (A: number[], C: number[], r = 0): number[] => {\n    if (r === 0) return A\n\n    const s = Math.sin(r)\n    const c = Math.cos(r)\n\n    const px = A[0] - C[0]\n    const py = A[1] - C[1]\n\n    const nx = px * c - py * s\n    const ny = px * s + py * c\n\n    return [nx + C[0], ny + C[1]]\n  }\n\n  /**\n   * Check of two vectors are identical.\n   * @param A\n   * @param B\n   */\n  static isEqual = (A: number[], B: number[]): boolean => {\n    return A[0] === B[0] && A[1] === B[1]\n  }\n\n  /**\n   * Interpolate vector A to B with a scalar t\n   * @param A\n   * @param B\n   * @param t scalar\n   */\n  static lrp = (A: number[], B: number[], t: number): number[] => {\n    return Vec.add(A, Vec.mul(Vec.sub(B, A), t))\n  }\n\n  /**\n   * Interpolate from A to B when curVAL goes fromVAL: number[] => to\n   * @param A\n   * @param B\n   * @param from Starting value\n   * @param to Ending value\n   * @param s Strength\n   */\n  static int = (A: number[], B: number[], from: number, to: number, s = 1): number[] => {\n    const t = (Vec.clamp(from, to) - from) / (to - from)\n    return Vec.add(Vec.mul(A, 1 - t), Vec.mul(B, s))\n  }\n\n  /**\n   * Get the angle between the three vectors A, B, and C.\n   * @param p1\n   * @param pc\n   * @param p2\n   */\n  static ang3 = (p1: number[], pc: number[], p2: number[]): number => {\n    // this,\n    const v1 = Vec.vec(pc, p1)\n    const v2 = Vec.vec(pc, p2)\n    return Vec.ang(v1, v2)\n  }\n\n  /**\n   * Absolute value of a vector.\n   * @param A\n   * @returns\n   */\n  static abs = (A: number[]): number[] => {\n    return [Math.abs(A[0]), Math.abs(A[1])]\n  }\n\n  static rescale = (a: number[], n: number): number[] => {\n    const l = Vec.len(a)\n    return [(n * a[0]) / l, (n * a[1]) / l]\n  }\n\n  /**\n   * Get whether p1 is left of p2, relative to pc.\n   * @param p1\n   * @param pc\n   * @param p2\n   */\n  static isLeft = (p1: number[], pc: number[], p2: number[]): number => {\n    //  isLeft: >0 for counterclockwise\n    //          =0 for none (degenerate)\n    //          <0 for clockwise\n    return (pc[0] - p1[0]) * (p2[1] - p1[1]) - (p2[0] - p1[0]) * (pc[1] - p1[1])\n  }\n\n  /**\n   * Get whether p1 is left of p2, relative to pc.\n   * @param p1\n   * @param pc\n   * @param p2\n   */\n  static clockwise = (p1: number[], pc: number[], p2: number[]): boolean => {\n    return Vec.isLeft(p1, pc, p2) > 0\n  }\n\n  /**\n   * Round a vector to the a given precision.\n   * @param a\n   * @param d\n   */\n  static toFixed = (a: number[], d = 2): number[] => {\n    return a.map((v) => +v.toFixed(d))\n  }\n\n  /**\n   * Snap vector to nearest step.\n   * @param A\n   * @param step\n   * @example\n   * ```ts\n   * Vec.snap([10.5, 28], 10) // [10, 30]\n   * ```\n   */\n  static snap(a: number[], step = 1) {\n    return [Math.round(a[0] / step) * step, Math.round(a[1] / step) * step]\n  }\n\n  /**\n   * Get the nearest point on a line with a known unit vector that passes through point A\n   * @param A Any point on the line\n   * @param u The unit vector for the line.\n   * @param P A point not on the line to test.\n   * @returns\n   */\n  static nearestPointOnLineThroughPoint = (A: number[], u: number[], P: number[]): number[] => {\n    return Vec.add(A, Vec.mul(u, Vec.pry(Vec.sub(P, A), u)))\n  }\n\n  /**\n   * Distance between a point and a line with a known unit vector that passes through a point.\n   * @param A Any point on the line\n   * @param u The unit vector for the line.\n   * @param P A point not on the line to test.\n   * @returns\n   */\n  static distanceToLineThroughPoint = (A: number[], u: number[], P: number[]): number => {\n    return Vec.dist(P, Vec.nearestPointOnLineThroughPoint(A, u, P))\n  }\n\n  /**\n   * Get the nearest point on a line segment between A and B\n   * @param A The start of the line segment\n   * @param B The end of the line segment\n   * @param P The off-line point\n   * @param clamp Whether to clamp the point between A and B.\n   * @returns\n   */\n  static nearestPointOnLineSegment = (\n    A: number[],\n    B: number[],\n    P: number[],\n    clamp = true\n  ): number[] => {\n    const u = Vec.uni(Vec.sub(B, A))\n    const C = Vec.add(A, Vec.mul(u, Vec.pry(Vec.sub(P, A), u)))\n\n    if (clamp) {\n      if (C[0] < Math.min(A[0], B[0])) return A[0] < B[0] ? A : B\n      if (C[0] > Math.max(A[0], B[0])) return A[0] > B[0] ? A : B\n      if (C[1] < Math.min(A[1], B[1])) return A[1] < B[1] ? A : B\n      if (C[1] > Math.max(A[1], B[1])) return A[1] > B[1] ? A : B\n    }\n\n    return C\n  }\n\n  /**\n   * Distance between a point and the nearest point on a line segment between A and B\n   * @param A The start of the line segment\n   * @param B The end of the line segment\n   * @param P The off-line point\n   * @param clamp Whether to clamp the point between A and B.\n   * @returns\n   */\n  static distanceToLineSegment = (A: number[], B: number[], P: number[], clamp = true): number => {\n    return Vec.dist(P, Vec.nearestPointOnLineSegment(A, B, P, clamp))\n  }\n\n  /**\n   * Push a point A towards point B by a given distance.\n   * @param A\n   * @param B\n   * @param d\n   * @returns\n   */\n  static nudge = (A: number[], B: number[], d: number): number[] => {\n    if (Vec.isEqual(A, B)) return A\n    return Vec.add(A, Vec.mul(Vec.uni(Vec.sub(B, A)), d))\n  }\n\n  /**\n   * Push a point in a given angle by a given distance.\n   * @param A\n   * @param B\n   * @param d\n   */\n  static nudgeAtAngle = (A: number[], a: number, d: number): number[] => {\n    return [Math.cos(a) * d + A[0], Math.sin(a) * d + A[1]]\n  }\n\n  /**\n   * Round a vector to a precision length.\n   * @param a\n   * @param n\n   */\n  static toPrecision = (a: number[], n = 4): number[] => {\n    return [+a[0].toPrecision(n), +a[1].toPrecision(n)]\n  }\n\n  /**\n   * Get an array of points (with simulated pressure) between two points.\n   * @param A The first point.\n   * @param B The second point.\n   * @param steps The number of points to return.\n   */\n  static pointsBetween = (A: number[], B: number[], steps = 6): number[][] => {\n    return Array.from(Array(steps)).map((_, i) => {\n      const t = i / (steps - 1)\n      const k = Math.min(1, 0.5 + Math.abs(0.5 - t))\n      return [...Vec.lrp(A, B, t), k]\n    })\n  }\n\n  /**\n   * Get the slope between two points.\n   * @param A\n   * @param B\n   */\n  static slope = (A: number[], B: number[]) => {\n    if (A[0] === B[0]) return NaN\n    return (A[1] - B[1]) / (A[0] - B[0])\n  }\n\n  /**\n   * Get a vector comprised of the maximum of two or more vectors.\n   */\n  static max = (...v: number[][]) => {\n    return [Math.max(...v.map((a) => a[0])), Math.max(...v.map((a) => a[1]))]\n  }\n\n  /**\n   * Get a vector comprised of the minimum of two or more vectors.\n   */\n  static min = (...v: number[][]) => {\n    return [Math.max(...v.map((a) => a[0])), Math.max(...v.map((a) => a[1]))]\n  }\n}\n\nexport default Vec\n", "import { Vec } from '@tldraw/vec'\n\nexport class Spline {\n  points: number[][] = []\n\n  lengths: number[] = []\n\n  totalLength = 0\n\n  private prev?: number[]\n\n  constructor(points: number[][] = []) {\n    this.points = points\n    this.lengths = points.map((point, i, arr) => (i === 0 ? 0 : Vec.dist(point, arr[i - 1])))\n    this.totalLength = this.lengths.reduce((acc, cur) => acc + cur, 0)\n  }\n\n  addPoint = (point: number[]) => {\n    if (this.prev) {\n      const length = Vec.dist(this.prev, point)\n      this.lengths.push(length)\n      this.totalLength += length\n      this.points.push(point)\n    }\n    this.prev = point\n  }\n\n  clear = () => {\n    this.points = this.prev ? [this.prev] : []\n    this.totalLength = 0\n  }\n\n  getSplinePoint = (rt: number): number[] => {\n    const { points } = this\n    const l = points.length - 1,\n      d = Math.trunc(rt),\n      p1 = Math.min(d + 1, l),\n      p2 = Math.min(p1 + 1, l),\n      p3 = Math.min(p2 + 1, l),\n      p0 = p1 - 1,\n      t = rt - d\n    const tt = t * t,\n      ttt = tt * t,\n      q1 = -ttt + 2 * tt - t,\n      q2 = 3 * ttt - 5 * tt + 2,\n      q3 = -3 * ttt + 4 * tt + t,\n      q4 = ttt - tt\n    return [\n      (points[p0][0] * q1 + points[p1][0] * q2 + points[p2][0] * q3 + points[p3][0] * q4) / 2,\n      (points[p0][1] * q1 + points[p1][1] * q2 + points[p2][1] * q3 + points[p3][1] * q4) / 2,\n    ]\n  }\n}\n", "import { Vec } from '@tldraw/vec'\nimport { Spline } from './spline'\n\ntype AnimationState = 'stopped' | 'idle' | 'animating'\n\ntype Animation = {\n  from: number[]\n  to: number[]\n  start: number\n  duration: number\n}\n\nexport class PerfectCursor {\n  state: AnimationState = 'idle'\n  queue: Animation[] = []\n  timestamp = performance.now()\n  lastRequestId = 0\n  timeoutId: any = 0\n  prevPoint?: number[]\n  spline = new Spline()\n  cb: (point: number[]) => void\n\n  constructor(cb: (point: number[]) => void) {\n    this.cb = cb\n  }\n\n  addPoint = (point: number[]) => {\n    clearTimeout(this.timeoutId)\n    const now = performance.now()\n    const duration = Math.min(now - this.timestamp, PerfectCursor.MAX_INTERVAL)\n    if (!this.prevPoint) {\n      this.spline.clear()\n      this.prevPoint = point\n      this.spline.addPoint(point)\n      this.cb(point)\n      this.state = 'stopped'\n      return\n    }\n    if (this.state === 'stopped') {\n      if (Vec.dist(this.prevPoint, point) < 4) {\n        this.cb(point)\n        return\n      }\n      this.spline.clear()\n      this.spline.addPoint(this.prevPoint)\n      this.spline.addPoint(this.prevPoint)\n      this.spline.addPoint(point)\n      this.state = 'idle'\n    } else {\n      this.spline.addPoint(point)\n    }\n    if (duration < 16) {\n      this.prevPoint = point\n      this.timestamp = now\n      this.cb(point)\n      return\n    }\n    const animation: Animation = {\n      start: this.spline.points.length - 3,\n      from: this.prevPoint,\n      to: point,\n      duration,\n    }\n    this.prevPoint = point\n    this.timestamp = now\n    switch (this.state) {\n      case 'idle': {\n        this.state = 'animating'\n        this.animateNext(animation)\n        break\n      }\n      case 'animating': {\n        this.queue.push(animation)\n        break\n      }\n    }\n  }\n\n  animateNext = (animation: Animation) => {\n    const start = performance.now()\n    const loop = () => {\n      const t = (performance.now() - start) / animation.duration\n      if (t <= 1 && this.spline.points.length > 0) {\n        try {\n          this.cb(this.spline.getSplinePoint(t + animation.start))\n        } catch (e) {\n          console.warn(e)\n        }\n        this.lastRequestId = requestAnimationFrame(loop)\n        return\n      }\n      const next = this.queue.shift()\n      if (next) {\n        this.state = 'animating'\n        this.animateNext(next)\n      } else {\n        this.state = 'idle'\n        this.timeoutId = setTimeout(() => {\n          this.state = 'stopped'\n        }, PerfectCursor.MAX_INTERVAL)\n      }\n    }\n    loop()\n  }\n\n  static MAX_INTERVAL = 300\n\n  dispose = () => {\n    clearTimeout(this.timeoutId)\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
